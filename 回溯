å›æº¯æ˜¯ä¸€ç§ç®—æ³•æ€æƒ³ï¼Œå®ƒçš„å…¸å‹ç‰¹å¾æ˜¯ï¼šğŸ‘‰ åœ¨é€’å½’çš„è¿‡ç¨‹ä¸­ï¼Œä¸ä»…ã€Œæ·±å…¥ã€ï¼Œè¿˜è¦ã€Œæ’¤é”€é€‰æ‹©ã€å›åˆ°ä¸Šä¸€æ­¥ï¼Œå†å°è¯•åˆ«çš„è·¯å¾„ã€‚
æ¢å¥è¯è¯´ï¼Œå›æº¯ä¾èµ–é€’å½’æ¥å®ç°ã€‚å›æº¯å’Œé€’å½’æœ€ä¸»è¦çš„åŒºåˆ«æ˜¯ï¼Œé€’å½’çš„ç›®çš„æ˜¯å‡½æ•°ä¸æ–­çš„è°ƒç”¨è‡ªèº«ï¼Œä»¥è®¡ç®—å‡ºè§£ï¼Œå›æº¯ä¸ä»…Â·åœ¨é€’å½’çš„è¿‡ç¨‹ä¸­ä¸æ–­çš„æ·±å…¥è°ƒç”¨ï¼Œè¿˜ä¼šæ’¤é”€è¿”å›ä¸Šä¸€æ­¥
å¸¸è§çš„åœºæ™¯ï¼šç»„åˆã€å…¨æ’åˆ—ã€æ•°ç‹¬ã€N çš‡åã€‚

ä¾‹é¢˜ï¼š
ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹rootï¼ŒæŒ‰ä»»æ„é¡ºåºï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res = []
        def dfs(node, path):
            if not node:
                return
            # æŠŠå½“å‰èŠ‚ç‚¹å€¼åŠ åˆ°è·¯å¾„
            path.append(str(node.val))
            # å¦‚æœæ˜¯å¶å­èŠ‚ç‚¹ï¼Œæ‹¼æ¥è·¯å¾„åŠ å…¥ç»“æœ
            if not node.left and not node.right: #åˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯ä¸æ˜¯å¶å­èŠ‚ç‚¹ã€‚å¶å­èŠ‚ç‚¹çš„å®šä¹‰ï¼šæ—¢æ²¡æœ‰å·¦å­æ ‘ï¼Œä¹Ÿæ²¡æœ‰å³å­æ ‘ã€‚æ¢å¥è¯è¯´ï¼Œåˆ°è¿™é‡Œè·¯å¾„èµ°åˆ°å¤´äº†
                res.append("->".join(path)) # "->".join(path)æŠŠè·¯å¾„åˆ—è¡¨è½¬æˆå­—ç¬¦ä¸²ï¼Œç”¨ -> è¿æ¥ã€‚"->".join(["1","2","5"]) â†’ "1->2->5"
            else:
                dfs(node.left, path)
                dfs(node.right, path)
            # å›æº¯ï¼šæ¢å¤åˆ°è¿›å…¥å½“å‰èŠ‚ç‚¹å‰çš„çŠ¶æ€
            path.pop()
        dfs(root, [])
        return res

