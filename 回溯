回溯是一种算法思想，它的典型特征是：👉 在递归的过程中，不仅「深入」，还要「撤销选择」回到上一步，再尝试别的路径。
换句话说，回溯依赖递归来实现。回溯和递归最主要的区别是，递归的目的是函数不断的调用自身，以计算出解，回溯不仅·在递归的过程中不断的深入调用，还会撤销返回上一步
常见的场景：组合、全排列、数独、N 皇后。

例题：
给你一个二叉树的根节点root，按任意顺序，返回所有从根节点到叶子节点的路径。叶子节点是指没有子节点的节点。
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res = []
        def dfs(node, path):
            if not node:
                return
            # 把当前节点值加到路径
            path.append(str(node.val))
            # 如果是叶子节点，拼接路径加入结果
            if not node.left and not node.right: #判断当前节点是不是叶子节点。叶子节点的定义：既没有左子树，也没有右子树。换句话说，到这里路径走到头了
                res.append("->".join(path)) # "->".join(path)把路径列表转成字符串，用 -> 连接。"->".join(["1","2","5"]) → "1->2->5"
            else:
                dfs(node.left, path)
                dfs(node.right, path)
            # 回溯：恢复到进入当前节点前的状态
            path.pop()
        dfs(root, [])
        return res

