1. 递归的本质是什么？
一句话：函数调用自己，用小问题解决大问题。
它包含三个核心要素：
（1）递归定义（函数的意义）
dfs(node) 要清楚它代表什么意思，比如：
返回某个值（最大深度、路径和…）
或者做某件事（统计、遍历）

（2）终止条件
什么时候不能再往下递归？
在二叉树题里通常是：if node is None: return ...

（3）递归关系（拆解子问题）
当前节点的问题 = 左子树的问题 + 右子树的问题
这就是二叉树题能用递归的原因。

👉 所以递归其实就是：定义清楚函数作用 → 确定停止点 → 拆解子问题 → 自己调用自己。


2. 二叉树递归的两种套路
在二叉树题里，递归函数大致分为两类：
⭐️⭐️⭐️(1) 有返回值型（靠系统调用栈“压栈/出栈”把返回值一层层传上来，冒泡问题，自底而上的dfs，树的高度、最大深度、平衡二叉树、是否相同树）
返回的是子树信息。递归函数本质是：问子树要答案，然后合并。一般只有 if root is None: return ... 这一种停止条件
例题：
最大深度：
def maxDepth(root):
    if not root:
        return 0
    left = maxDepth(root.left)
    right = maxDepth(root.right)
    return max(left, right) + 1
定义：maxDepth(node) = 以 node 为根的最大深度
终止条件：node 为空，深度 = 0
递归关系：深度 = 左右子树深度的最大值 + 1

例题：
给你一棵完整二叉树的根，这棵树有以下特征：叶子节点要么值为0要么值为1，其中0表示False，1表示True。非叶子节点要么值为2要么值为3，其中2表示逻辑或OR，3表示逻辑与AND。
计算 一个节点的值方式如下：
如果节点是个叶子节点，那么节点的值为它本身，即True或者False。否则，计算两个孩子的节点值，然后将该节点的运算符对两个孩子值进行运算。返回根节点root的布尔运算值。
完整二叉树是每个节点有0个或者2个孩子的二叉树。
class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        if root.left is None: # 停止条件是当前节点为叶节点
            return bool(root.val)
        l = self.evaluateTree(root.left)
        r = self.evaluateTree(root.right)
        return l or r if root.val == 2 else l and r


例题：
给出一棵二叉树，其上每个结点的值都是0或1。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为0->1->1->0->1，那么它表示二进制数01101，也就是13 。
对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。返回这些数字之和。题目数据保证答案是一个32位整数。
class Solution:
    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
        ans = 0
        def Solution(root, ans):
            if root is None:
                return 0
            ans = root.val + ans * 2
            # 到叶节点，返回当前路径值
            if root.left is None and root.right is None:
                return ans
            return Solution(root.left, ans) + Solution(root.right, ans)
        return Solution(root, ans)


例题：
给你二叉树的根结点root，此外树的每个结点的值要么是0，要么是1 。返回移除了所有不包含1的子树的原二叉树。节点node的子树为node本身加上所有node的后代。
class Solution:
    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root==None:
            return None
        root.left,root.right=self.pruneTree(root.left),self.pruneTree(root.right)
        if root.left==None and root.right==None and root.val==0:
            return None
        return root 


⭐️⭐️⭐️(2) 无返回值型（必须靠外部变量记录答案，自上到下的dfs，比如路径问题、累加问题）
函数的定义：给我一个节点和额外参数，我帮你遍历并收集答案。
返回的是路径/过程的最终结果。递归函数本质是：带着状态一路走，直到叶子结点“收割答案”。所以需要额外的 “叶子结点条件” 来真正触发结果。
例题：
统计好节点：给你一棵根为root的二叉树，请你返回二叉树中好节点的数目。好节点X定义为：从根到该节点X所经过的节点中，没有任何节点的值大于X的值。
class Solution:
    def goodNodes(self, root: TreeNode, mx=-inf) -> int:
        if root is None: # 停止条件，root为空
            return 0
        left = self.goodNodes(root.left, max(mx, root.val)) # 函数做事，从上到下递归
        right = self.goodNodes(root.right, max(mx, root.val))
        return left + right + (mx <= root.val) # 最后左右子树值与根节点

class Solution:
    def goodNodes(self, root: Optional[TreeNode],max_num = -inf) -> int:
        if root is None:
            return 0
        max_num = max(max_num,root.val) 
        return self.goodNodes(root.left,max_num) + self.goodNodes(root.right,max_num) + (root.val >= max_num)


3. 为什么二叉树特别适合递归？
因为二叉树天然满足“结构相似”：一棵树的左子树、右子树本身也是一棵树，所以问题可以自然地分解成左右子树的子问题
例子：最大深度
      A
     / \
    B   C
maxDepth(A)
= 1 + max(maxDepth(B), maxDepth(C))
自然递归！


4. 如何理解递归过程？
很多人晕是因为看不到递归的展开。
👉 技巧：模拟递归调用栈。
模拟调用栈 就是把程序运行时真实发生的“函数调用帧被压栈/出栈”的过程 手动复现出来：每次调用把一个“帧”写下来（包含参数、本地变量、当前要做的事），遇到递归调用就把新帧压上去；遇到 return 就把当前帧弹出并把返回值写回到上一帧。
例子：
def fact(n):
    if n == 0:
        return 1
    return n * fact(n-1)
模拟 fact(3)：
用列表表示栈（左端是栈底，右端是栈顶）：
初始： push fact(3)
Frame: fact(3) { waiting for fact(2) }
执行到 fact(3) 的 return → 需要 fact(2)，所以 push fact(2)
Stack: fact(3), fact(2)

fact(2) 需要 fact(1)，push fact(1)
Stack: fact(3), fact(2), fact(1)

fact(1) 需要 fact(0), push fact(0)
Stack: fact(3), fact(2), fact(1), fact(0)

fact(0) 碰到 base case，直接 return 1。

pop fact(0)，把 1 返回给 fact(1)

fact(1) 收到 fact(0)=1，计算 1 * 1 = 1，return 1。

pop fact(1)，把 1 返回给 fact(2)

fact(2) 收到 1，计算 2 * 1 = 2，返回 2。pop。

fact(3) 收到 2，计算 3 * 2 = 6，返回 6。结束。

这个过程很直观：你把 “调用链” 一层层压进去，然后从最深处一层层弹出来并计算。


5. 二叉树题递归的固定模板
以后写递归题时，可以套这两个模板：
✅ 有返回值型模板（计算结果）
def dfs(node) -> int:
    if not node:
        return 0
    left = dfs(node.left)
    right = dfs(node.right)
    return max(left, right) + 1

✅ 无返回值型模板（遍历做事）
def dfs(node, extra):
    if not node:
        return
    # 在这里对 node 做点事
    dfs(node.left, new_extra)
    dfs(node.right, new_extra)


6. 总结
递归本质：函数调用自己，用小问题解决大问
关键要素：函数定义、终止条件、递归关系
二叉树常见：
（1）有返回值型（最大深度、路径和）
（2）无返回值型（收集答案、统计数量）

思考方式：把 dfs(node) 当成“黑箱函数”，只关心它的定义，不要去追递归细节。


7. 递归返回最上层问题
def f(x): 
    if x == 0: 
        return True 
    else: 
        f(x-1) # ❌ 递归结果被丢掉，这里没有返回true，因为虽然递归到了f（0），但是没有把其递归到最上层，函数收不到结果

def f(x):
    if x == 0:
        return True
    else:
        return f(x-1)  # ✅ 递归结果传回上层
